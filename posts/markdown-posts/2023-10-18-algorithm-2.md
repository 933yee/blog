---
date: 2023-10-18
title: 演算法筆記 Chapter 6 ~ 9
subtitle: 大三資工上學期必修
category: personal-note
frontCover: https://miro.medium.com/v2/resize:fit:2000/1*GdCKWdjHLUGhkPoXjI6vIQ.jpeg
tag: personal-note, courses, algorithm
---
### Chapter 6: Heap
- Shape Property
  - All levels, except deepest, are fully filled
  - Deepest level is filled from left to right 
- Heap Property
  - Value of a node ≤ Value of its children


#### PQ Representations
```img
heap_table.png
```

#### Max Heap
##### Definition
  - the **key value** in each node is **no smaller** than the key values in its children
  - complete binary tree
  ```img
  heap_example.png
  ```
  ```img
  heap_counter_example.png
  ```
##### Representation
- Since Heap is a complete binary tree, we could adop **Array Representation**.
- Let **1** be the root, that is, **Array[1]** is root and **Array[0]** is empty.
    - Parent(i) = `latex \lfloor` i/2 `latex \rfloor`
    - leftChild(i) = 2i 
    - rightChild(i) = 2i+1 

##### Operations
  - **Insert**
      1. Insert to the last position.
      2. Check if the new node is greater than its parent. 
      3. If so, swap two nodes and keep checking Step 2.
      - Example: insert 5 
      ```img
      heap_insert_ex.png
      ```

      ```cpp
          void push(node n){
              nodes[++sz] = n;
              int idx = sz;
              while(idx / 2){
                  if(nodes[idx/2].weight > nodes[idx].weight){
                      swap(nodes[idx/2], nodes[idx]);
                      idx /= 2;
                  }else 
                      break;
              }
          }
      ```    

  - **Delete**
      1. Delete the root.
      2. Move the last element to the root.
      3. Check if the cuurent node is smaller than its children. 
      4. If so, swap the largest child and keep checking Step 3.

      - Example: delete
      ```img
      heap_delete_ex.png
      ```
 
      ```cpp
          void pop(){
              nodes[1] = nodes[sz--];
              int idx = 1;
              while(idx * 2 <= sz){
                  if(idx * 2 + 1 <= sz && nodes[idx*2+1].weight < nodes[idx*2].weight && nodes[idx*2+1].weight < nodes[idx].weight){
                      swap(nodes[idx], nodes[idx*2+1]);
                      idx = idx * 2 + 1;
                  }else if(nodes[idx*2].weight < nodes[idx].weight){
                      swap(nodes[idx], nodes[idx*2]);
                      idx = idx * 2;
                  }else break;
              }
          }
      ```    

  - [Heap Visualization](https://www.cs.usfca.edu/~galles/visualization/Heap.html)

#### Fixing heap property for all nodes
- Suppose a binary tree satisfies **shape property** but **heap property** not be satisfied, how to make the tree a heap in O(n) time?
##### Heapify
  - u = root of binary
  - L = subtree rooted at u's left child
  - R = subtree rooted at u's right child
  - If L and R satisfy heap property, we can make the tree rooted at u satisfy heap property in **O(max{height(L), height(R)})** time

Back to the challenge, we know
- Let h = height of tree
  - `latex 2^{h-1} \le n \le 2^h - 1`
- Then, total time `latex T` is
  - (最後一層全部 heapify) + (倒數第二層全部 heapify) + ... `latex \\ = (2^{h-1} \cdot 1) + (2^{h-2} \cdot 2) + (2^{h-3} \cdot 3) + ... + (1 \cdot h) \\ = 2^h (1 \cdot \frac{1}{2} + 2 \cdot (\frac{1}{2})^2 + 3 \cdot (\frac{1}{2})^3 + ... + h \cdot (\frac{1}{2})^h) \\ \le 2^h \Sigma_{k=1}^{\infty} k \cdot \frac{1}{2}^k `
- let `latex A = \Sigma_{k=1}^{\infty} k \cdot \frac{1}{2}^k`
  - `latex 2A - A \\ = (1 + \frac{2}{2} + \frac{3}{4} + \frac{4}{8} + ...) - (\frac{1}{2} + \frac{2}{4} + \frac{3}{8} + ...) \\ = 1 + \frac{1}{2} + \frac{1}{4} + \frac{1}{8} + ... `(等比級數)`latex \\= 2 `

- Hence, `latex T \le 2^h \Sigma_{k=1}^{\infty} k \cdot \frac{1}{2}^k = 2^h \cdot 2 \le 2n`, the total time T is `latex O(n)` 

<br>

### Chapter 7: Qucik sort
- Worst-case: `latex \theta(n^2)`
- Average-case: `latex \theta(n log n)`

#### Partition
- Use A[r] (the last element) as pivot
- Process A[p..r] from left to right
- Use two counters: 
    - One for the **length of the prefix**
    - One for the **element we are looking**
- The prefix of A stores all elements less than pivot seen so far
```cpp
PARTITION (A, p, r):
    x = A[r]
    i = p-1
    for j = p to r-1
        if A[j] <= x
            i = i + 1
            exchange A[i] with A[j]
    exchange A[i+1] with A[r]
    return i + 1
```

```cpp
Quicksort(A,p,r): /* to sort array A[p..r] */
    if (p < r) 
        q = Partition(A, p, r); 
        Quicksort(A, p, q - 1);
        Quicksort(A, q + 1, r);
```
- **可以用 random 取 pivot 的位置**

#### Worst-Case Running Time
- The worst-case running time can be expressed by 
  - `latex T(n) = max_{q = 0\; to\; n-1}(T(q)+T(n-q-1))+\Theta(n)`
- By **substitution method**:
  - Guess `latex T(n) \le cn^2` for some constant c
  - Verify by induction:
    - For `latex n = 1`, `latex T(n) \le cn^2 = c` for any `latex c \ge 1`
    - Assume for `latex n \le k`, `latex T(n) \le cn^2`
    - Then, for `latex n = k + 1`, <br>
       `latex T(n) = max_{q = 0\; to\; n-1}(T(q)+T(n-q-1))+\Theta(n) \\\qquad\; \le max_{q = 0\; to\; n-1}(cq^2+c(n-q-1)^2)+\Theta(n) \; ` (maximized when **q = 0** or **q = n - 1**) `latex \\\qquad\;= c(n-1)^2 + \Theta(n) \\\qquad\;= cn^2 - 2cn + c +\Theta(n) \\\qquad\;\le cn^2` when c is large enough
    - Hence,  `latex T(n)=O(n^2)`
- By **substitution method**:
  - Guess `latex T(n) \ge cn^2` for some constant c
  - Verify by induction:
    - For `latex n = 1`, `latex T(n) \ge cn^2 = c` for any `latex c = 1`
    - Assume for `latex n \le k`, `latex T(n) \ge cn^2`
    - Then, for `latex n = k + 1`, <br>
       `latex T(n) = max_{q = 0\; to\; n-1}(T(q)+T(n-q-1))+\Theta(n) \\\qquad\; \ge max_{q = 0\; to\; n-1}(cq^2+c(n-q-1)^2)+\Theta(n) \; ` (maximized when **q = 0** or **q = n - 1**) `latex \\\qquad\;= c(n-1)^2 + \Theta(n) \\\qquad\;= cn^2 - 2cn + c +\Theta(n) \\\qquad\;\ge cn^2` when c is samll enough
    - Hence,  `latex T(n)=O(n^2)`


#### Average Running Time
- Let X = number of **comparisons** in all Partition
- n = number of **Partition calls**
- Running time = **O( n + X )** 
- Compute average of X
  - Let `latex a_1, a_2, a_3, ..., a_n` denote the set of n numbers initially placed in the array. And `latex a_1 < a_2 < a_3 < ... < a_n`, so `latex a_1` may not be the element in A[1] originally
  - Let `latex X_{ij}` = number of **comparisons** between `latex a_i` and `latex a_j` in all Partition calls
- Then, `latex X = X_{12} + X_{13} + ... + X_{n-1, n}`
- Average number of comparisons <br>
  `latex = E[X] \\= E[X_{12} + X_{13} + ... + X_{n-1, n}] \\= E[X_{12}] + E[X_{13}] + ... + E[X_{n-1, n}]`
- Consider the elements `latex a_i, a_{i+1}, ..., a_{j-1}, a_j`
  - If `latex a_i` or `latex a_j` is first chosen as a pivot, then `latex a_i` is compared with `latex a_j` once <br>
  `latex \rightarrow \frac{2}{j-i+1}` 
  - Else, if any elements of `latex a_{i+1}, ..., a_{j-1}` is first chosen as a pivot, then `latex a_i` is never compared with `latex a_j` <br>
  `latex \rightarrow \frac{j-i-1}{j-i+1}`<br>
  - `latex E[X_{ij}] = 1 \cdot \frac{2}{j-i+1} + 0 \cdot \frac{j-i-1}{j-i+1} = \frac{2}{j-i+1}`
- Back to `latex E[X] = E[X_{12}] + E[X_{13}] + ... + E[X_{n-1, n}]`, 
  - `latex E[X] = \Sigma_{i=1}^{n-1} \Sigma_{j=i+1}^{n} \frac{2}{j-i+1}  \\\qquad\; = \Sigma_{i=1}^{n-1} \Sigma_{k=1}^{n-i} \frac{2}{k+1} \\\qquad\; < \Sigma_{i=1}^{n-1} \Sigma_{k=1}^{n} \frac{2}{k} \\\qquad\; = \Sigma_{i}^{n-1} O(lgn) = O(n \cdot lg n)`

- Hence, the time used is `latex O(n + X)`, averge is `latex O(n \cdot lg n)`


### Chapter 8

#### Comparison Sort
- Quick sort, Merge sort, Heap sort, Insertion sort...
- For any **Decision Tree** of comparison sort, there are **n!** leaves
- Let **h** be the height of the tree
- So, `latex n! ` = total number of leaves `latex \le 2^h`<br>
    `latex h \ge lg(n!) = lg n + lg(n-1) + ... + lg(1) \\\quad\ge lgn + ... + lg(\frac{n}{2}) \\\quad\ge (n/2)lg(n/2) = \Omega(n \cdot lgn)`
- Hence, For any comparison sort, even the cleverest one, needs `latex \Omega(n \cdot lgn)` comparisons in the worst case
  - Heap sort and Merge sort are asymptotically optimal comparison sorts

#### Sorting in Linear Time

##### Counting sort
- Running time = `latex O(n + k)`
- **Stable**

- Example
  - Input: Array A[1..n] of n integers, each has value from [0, **k**]
  - Output: Sorted array of the n integers
  - Idea:
    - Create B[1..n] to store the output
    - Process A[1..n] from right to left (To be **stable**)
- Steps
  1. Initialize c[0], c[1], …, c[k] to 0 <br>
     For x = 1, 2, ..., n, increase c[A[x]] by 1 <br>
     For x = 1, 2, ..., n, c[x] = c[x-1] + c[x]<br>
    Time for Step 1: `latex O( n + k )`
  2. ```cpp
        for x = n downto 1
            B[c[A[x]]] = A[x]; 
            Decrease c[A[x]] by 1;
        ``` 
        Time for Step 2 = `latex O(n)`

##### Radix Sort
- Running time = `latex O(d (n + k))`
- **Stable**
- Example
  - Input: Array A[1..n] of n integers, each has **d** digits, and each digit has value from [0, **k**]
  - Output: Sorted array of the n integers
  - Idea:
    - Sort in d rounds
      - At Round j, stable sort A on digit j 
```img
https://upload.wikimedia.org/wikipedia/commons/0/04/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.gif
```

##### Bucket Sort
- Average running time = `latex \Theta(n + k)`
  - k buckets
- Worst running time = `latex O(n^2)`
- Example
```img
https://media.geeksforgeeks.org/wp-content/uploads/20210224162956/ezgifcomgifmaker14.gif
```
- 每個 butcket 數量不多，所以 **Innersort** 可以採用 **Insertion Sort** 確保 **Stable**