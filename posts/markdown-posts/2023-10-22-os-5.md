---
date: 2023-10-22
title: 作業系統筆記 (5)
subtitle: Threads
category: personal-note
frontCover: https://www.ionos.com/digitalguide/fileadmin/DigitalGuide/Teaser/operating-system-t.jpg
tag: personal-note, courses, os
---
### Threads
- AS known as **lightweight process**
  - basic unit of CPU utilization
- All threads of a process share 
  - code section, data section, open files, signals
- Each thread has its own
  - thread ID, program counter, register set, **stack**
  - thread control block can be used to save thread state, analogous to PCB for process

#### Example
- web browser
  - one thread displays content
  - another thread receives data from network
- web server
  - spawn one process per requeset -> too heavyweight
  - use threads -> light weight, better sharing of code and resources
- RPC server
  - one RPC requset per thread

```img
thread-example.png
```

#### Benefits of Multithreading
- Responsiveness
  - one thread blocked, another thread may perform a lengthy operation
- Resources Sharing
  - several threads run in the same address space, easier sharing than interprocess shared memory or message passing
- Economy
  - process-level operation is heavyweight
  - Solaris: process creation is 30x as slow as thread creation, context switch with process is 5x slower than thread switching
  - threads: switch register set but **not memory management**
- Scalability
  - threads may run in parallel on multiprocessor

#### Challenges in Multicore Programming
- Computation partitionng
  - into concurrent tasks
- Balancing
  - evenly distribute tasks to cores
- Data splitting
  - data units to expose data parallelism
- Data dependency
  - synchronize data access
- Testing and debugging

#### Concurrency vs. Parallelism
- Concurrency
  - multiple tasks **acive** at the same time
    - 不一定要執行
  - one running at a time on single-core system
  - may run in parallel on multi-core
  - a requirement for parallelism
    - parallel 一定是 concurrent，concurrent 不一定是 parallel
- Parallelism
  - running multiple tasks simultaneously
  - requires a multi-core system

#### Multicore Programming
- Multicore architectures
  - Cores can share same physical memory
- Each core could support multiple hardware threads
  - SMT (simultaneous multithreading) architectures, e.g, Intel Hyperthreading
    - keep your pipeline heavily utilized
    - same core but pipelined
    - 不是指說是 multi-core，但是可以支援 multi-core
- Multithreading good match with mult-core
  - Parallelism: threads can run in parallel if OS schedules them on multiple cores
  - data parallelism vs task parallelism

#### Data Parallelism
- same task running on different data
  - data may be segmented or multiple streams
  - different parts can be processed in parallel
- Examples
  - matrix multiply
  - dot-products are data-parallel

#### Task Parallelism
- The problem can be decomposed
  - into threads that have little mutual dependency
  - each thread runs potentially different code
- Examples
  - servers that serve a variety of requests
    - http, ftp, cloud drive, streaming, ...
  - Multimedia, games: audio, graphics, networking
    - but onlt up to a limit (e.g, frame), and they need to synchronize (fork-join parallelism)
      - 雖然彼此獨立，但是一段時間還是要統一
       
#### Pipeline Parallelism
- Divide a task into stages
  - Each stage is executed on its own processor
  - Assuming data is streamed
- Example: 3D graphics pipeline for gaming
  - application (character action, game rules)
  - geometry (lighting, projection, clipping, viewpoint)
  - rasterization (hidden surface removal, texture, shading, alpha blending/ antialiasing)
- One stage depends on previous stage ofr input

#### Series-Parallel parallelism
- Also called fork-join parallelism
  - program starts out serial
  - can spawn threads ("forl") to do work concurrently
  - threads synchronize ("join) after they finish
  - programs executes in series for a while, then fork...
- Common for recursive algorithms
  - "divide-and-conquer": merge sort, quick sort, etc.
  - supported as "fork-join" constructs by some languages or threads packages


#### User thread vs. Kernel thread
- User threads
  - thread management done by **user-level thread library**
  - OS only sees processes; does not see user threads
  - Generally **fast** to create and manage
  - **If the kernel is single-threaded, a user-thread blocks causes entire process blocks** even if other threads are ready to run
    - user thread 要 bind 到 kernel thread
- Kernel threads
  - Managed by the OS kernel directly
  - Generally **slow** to create and manage
  - does not mean "threads that run in kernel mode" (they could, but could switch to user mode to run the process)

##### Multithreading models
- Many-to-One
  - Thread management is done in user space, so it is efficient
  - The entire process will block if a thread makes a blocking system call
  - Only one thread can access the kernel at a time **multiple threads are unable to run in parallel on multiprocessors**
- One-to-Many
  - There could be a limit on number of kernel threads
  - More concurrency
  - Creating a thread requires creating the corresponding kernel thread
- Many-to-Many
  - Allows the developer to create as many user threads as wished
  - The corresponding kernel threads can run in parallel on a multiprocessor
  - When a thread performs a blocking call, the kernel can schedule another thread for execution
  - Overhead 會比較大